BuildMST <- function(fsom, silent=FALSE){
    # Add minimal spanning tree description to the FlowSOM object
    #
    # Args:
    #     fsom: FlowSOM object, as generated by BuildSOM
    # 
    # Returns:
    #     FlowSOM object containg MST description
    
    fsom$MST <- list()
    if(!silent) message("Building MST\n")
    adjacency <- dist(fsom$map$codes, method = "euclidean")
    fullGraph <- graph.adjacency(as.matrix(adjacency), mode = "undirected", 
                                weighted = TRUE)
    fsom$MST$graph <- minimum.spanning.tree(fullGraph)
    fsom$MST$l <- layout.kamada.kawai(fsom$MST$graph)
    UpdateNodeSize(fsom)
}

UpdateNodeSize <- function(fsom, reset=FALSE){
    # Add size property to the graph based on cellcount for each node
    #
    # Args:
    #     fsom:    FlowSOM object, as generated by BuildMST
    #     reset: logical. If T, all nodes get the same size
    #
    # Returns:
    #     Updated FlowSOM object
    if(reset){
        fsom$MST$size <- rep(15, nrow(fsom$map$grid))
    } else {
        t <- table(fsom$map$mapping[, 1])
        cuts <- 14* (t - min(t))/max((t - min(t)))
        #cuts <- as.numeric(cut(t, breaks = 9))
        fsom$MST$size <- numeric(nrow(fsom$map$grid))
        fsom$MST$size[as.numeric(names(t))] <- cuts    
    }
    fsom
}

PlotMarker <- function(fsom, marker=NULL, MST=TRUE,main=NULL, 
                        colorPalette=colorRampPalette(c("#00007F", "blue", 
                        "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00",
                        "red", "#7F0000"))){
    # Plot FlowSOM grid or tree, coloured by node values for a specific marker
    #
    # Args:
    #     fsom: FlowSOM object, as generated by BuildMST
    #     marker: Name or index of marker to plot
    #     MST: logical. If TRUE, plot tree, else plot grid
    
    if(MST){
        layout <- fsom$MST$l 
        lty <- 1
    } else {
        layout <- as.matrix(fsom$map$grid)
        lty <- 0
    }
    if(is.null(main)) main <- marker
    
    if(is.null(marker)){
        plot(fsom$MST$graph, layout=layout, vertex.size=fsom$MST$size, 
            vertex.label=NA,edge.lty=lty)
    }else{
        f <- fsom
        V(f$MST$graph)$color <- colorPalette(100)[as.numeric(cut(
                        fsom$map$meanValues[, marker], breaks = 100))] 
        plot(f$MST$graph, layout=layout, vertex.size=fsom$MST$size, 
            vertex.label=NA, main=main,edge.lty=lty)
    }
}

PlotPies <- function(fsom, cellTypes, MST=TRUE, legend=TRUE, clusters=NULL,
                    main="",colorPalette=colorRampPalette(c("white","#00007F",
                    "blue", "#007FFF", "cyan", "#7FFF7F", "yellow", "#FF7F00",
                    "red"))){
    # Plot FlowSOM grid or tree, coloured by node values for a specific marker
    #
    # Args:
    #     fsom:      FlowSOM object, as generated by BuildMST
    #     cellTypes: Array of factors indicating the celltypes
    #     MST:       logical. If True, plot tree, else plot grid
    #     legend:    logical. Sometimes the position of the legend is 
    #                not great, so it might be easier to plot without
    #     clusters:  optional, clustering of the SOM nodes
    
    if(MST){
        layout <- fsom$MST$l 
        lty <- 1 # Draw edges
    } else {
        layout <- as.matrix(fsom$map$grid)
        lty <- 0
        #lty <- 1
    }
    
    # Use clusters for background color
    clusterList <- list()
    clusterColors <- NULL
    if(!is.null(clusters)){
        tmpClusterList <- lapply(unique(clusters), function(cluster) {
                                    which(clusters == cluster)})
        tmpColors <- rainbow(length(tmpClusterList), alpha=0.3)
        for(cl in seq_along(tmpClusterList)){
            subClusterList <- as.list(tmpClusterList[[cl]])
            clusterList <- c(clusterList, subClusterList)
            clusterColors <- c(clusterColors, 
                                rep(tmpColors[cl], length(subClusterList)))
        }
    }
    
    # Calculate percentage of each celltype per node
    nclusters <- length(unique(cellTypes))
    nnodes <- nrow(fsom$map$codes)
    percentages <- matrix(+1e-13, nrow=nnodes, ncol=nclusters)
    t <- table(fsom$map$mapping[, 1], cellTypes)
    percentages[as.numeric(rownames(t)), ] <- (t/rowSums(t))+1e-13
    percentages_list <- split(percentages, rep(1:nnodes, nclusters))
    colors <- split(rep(colorPalette(nclusters), nnodes), 
                                    rep(1:nnodes, each=nclusters))
    
    oldpar <- par()
    par(mar=c(1,1,1,1))
    # Plot legend
    if(legend){
        layout(matrix(c(1,2), 1, 2, byrow = TRUE), 
            widths=c(1,2), heights=c(1))
        plot.new()
        legend("left", legend= colnames(t), fill=colors[[1]], cex=0.7, 
            ncol=1, bty="n")
    }
    # Plot figure
    plot(fsom$MST$g, 
            vertex.shape="pie", 
            vertex.label=NA, 
            vertex.size=fsom$MST$size, 
            vertex.pie=percentages_list, 
            vertex.pie.color=colors,    
            layout=layout, 
            edge.lty=lty, 
            mark.groups=clusterList, 
            mark.col=clusterColors, 
            mark.border=clusterColors,
            main=main
    )
    suppressWarnings(par(oldpar))
}

# Internal use only:
# Add a new vertex shape to iGraph to make star charts
mystar <- function(coords, v=NULL, params) {
    vertex.color <- params("vertex", "color")
    if (length(vertex.color) != 1 && !is.null(v)) {
        vertex.color <- vertex.color[v]
    }
    vertex.size    <- 1/200 * params("vertex", "size")
    if (length(vertex.size) != 1 && !is.null(v)) {
        vertex.size <- vertex.size[v]
    }
    data <- params("vertex", "data")
    cP <- params("vertex","cP")
    stars(data, locations = coords, labels = NULL,#scale=FALSE, 
                len = vertex.size, col.segments = cP, 
                draw.segments = TRUE, mar = c(0, 0, 0, 0), add=TRUE, 
                inches=FALSE)
    symbols(coords[, 1], coords[, 2], circles = vertex.size, 
                    inches = FALSE, bg = "transparent", bty='n', add=TRUE) 
    
}


PlotStars <- function(fsom, markers=fsom$map$colsUsed, MST=TRUE, legend=TRUE, 
                    clusters=NULL,main="",colorPalette=colorRampPalette(
                    c("#00007F", "blue", "#007FFF", "cyan", "#7FFF7F", 
                    "yellow", "#FF7F00", "red", "#7F0000"))){
    # Plot FlowSOM grid or tree, where each node is represented by a star chart
    # indicating mean marker values
    #
    # Args:
    #     fsom:     FlowSOM object, as generated by BuildMST
    #     markers:  Array of markers to use. Default: the markers used to 
    #               build the tree
    #     MST:      logical. If True, plot tree, else plot grid
    #     legend:   logical. Sometimes the position of the legend is not great,
    #               so it might be easier to plot without
    #     clusters: optional, clustering of the SOM nodes
    add.vertex.shape("star", clip=igraph.shape.noclip, plot=mystar, 
                    parameters=list(vertex.data=NULL,vertex.cP=
                    colorRampPalette(c("#00007F", "blue", "#007FFF", "cyan",
                    "#7FFF7F", "yellow", "#FF7F00", "red", "#7F0000"))))
    
    if(MST){
        layout <- fsom$MST$l 
        lty <- 1
    } else {
        layout <- as.matrix(fsom$map$grid)
        lty <- 0
    }
    
    clusterList <- list()
    clusterColors <- NULL
    if(!is.null(clusters)){
        tmpClusterList <- lapply(unique(clusters), function(cluster) {
                                            which(clusters == cluster)})
        tmpColors <- rainbow(length(tmpClusterList), alpha=0.3)
        for(cl in seq_along(tmpClusterList)){
            subClusterList <- as.list(tmpClusterList[[cl]])
            clusterList <- c(clusterList, subClusterList)
            clusterColors <- c(clusterColors, 
                rep(tmpColors[cl], length(subClusterList)))
        }
    }
    
    data <- fsom$map$meanValues[, markers]
    
    oldpar <- par()
    par(mar=c(1,1,1,1))
    if(legend){
        layout(matrix(c(1,2), 1, 2, byrow = TRUE), 
            widths=c(1,2), heights=c(1))
        plot.new()
        legend("center", legend= fsom$prettyColnames[markers], 
            fill=colorPalette(ncol(data)), cex=0.7, ncol=1, bty="n")
    }
    plot(fsom$MST$g, 
            vertex.shape="star", 
            vertex.label=NA, 
            vertex.size=fsom$MST$size, 
            vertex.data=data,
            vertex.cP=colorPalette(ncol(data)),
            layout=layout, 
            edge.lty=lty, 
            mark.groups=clusterList, 
            mark.col=clusterColors, 
            mark.border=clusterColors,
            main=main
    )
    suppressWarnings(par(oldpar))
}

PlotCenters <- function(fsom, marker1, marker2, MST=TRUE){
    # Plot FlowSOM nodes on a 2D scatter plot of the data
    #
    # Args:
    #     fsom:    FlowSOM object, as generated by BuildMST
    #     marker1: Marker to show on the x-axis
    #     marker2: Marker to show on the y-axis
    #     MST:     logical. If True, plot tree, else plot grid
        
    plot(fsom$data[, c(marker1, marker2)], pch=".", col="#000000AA")
    d <- fsom$map$meanValues[, c(marker1, marker2)]
    points(d,col="red")
    
    if(MST){
        g <- fsom$MST$graph
        e <- get.edges(g, E(g))
    } else {
        e <- which(as.matrix(
                stats::dist(fsom$map$grid,method = "manhattan"))==1,
                arr.ind=TRUE)
    }
    
    for(i in seq_len(nrow(e))){
        lines(d[c(e[i, 1], e[i, 2]), 1], d[c(e[i, 1], e[i, 2]), 2], col="red")
    }
}

FlowSOMSubset <- function(fsom,ids){
    fsom_tmp <- fsom
    fsom_tmp$data <- fsom$data[ids,]
    fsom_tmp$map$mapping <- fsom$map$mapping[ids,]
    aggr <- aggregate(fsom_tmp$data,by=list(fsom_tmp$map$mapping[,1]),mean)
    fsom_tmp$map$meanValues <- matrix(0,nrow = nrow(fsom$map$grid),
                                    ncol = ncol(fsom$map$meanValues))
    fsom_tmp$map$meanValues[aggr[,1],] <- as.matrix(aggr[,-1])
    UpdateNodeSize(fsom_tmp)
}